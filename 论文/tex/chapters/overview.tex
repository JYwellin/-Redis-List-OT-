\chapter{$PaxosStore$设计概览}
\label{chapter:overview}
\par 本章将概述腾讯应用于微信的高可用存储系统$PaxosStore$的设计背景，说明其整体设计思路，并给出其基于的算法——$Paxos$算法部分的证明，并以此为基石，研究更一般的基于共享变量，数据副本修改的$Paxos$算法的正确性。
\section{$PaxosStore$设计背景}
	\label{section:struct}
	\par 微信是一个日活跃用户数达到7亿的$APP$，其提供了立即消息传输，社交网络建立，移动支付，第三方认证等服务。微信提供服务的后台包含许多不同功能的模块，尽管业务逻辑的多样性，大多数模块都需要可靠的存储来支持它们的实现。起初，每个研发团队采用商用数据存储系统来支撑他们的开发，但是，在实际生产中，太多碎片化的存储系统不但需要很多精力来维护，而且也造成这些系统很难大规模部署。所有这些导致微信需要一个统一的存储系统来为他的业务提供支撑，于是微信开发了第二代存储系统$PaxosStore$。
	\par 支撑腾讯的存储系统必须满足以下条件：首先，存储数据的体量大，存储时延低，数据多样化。这是大数据的3$V$要求。因为腾讯每天会处理大约 $1.5TB$的数据，这些数据包括短消息，图片，视频，转账记录，朋友圈推送等。应用对数据库的询问保持在每秒1万次。其次，高可用性比数据的存储本身更重要，尤其是对点对点消息，群聊消息，朋友圈消息的存储访问。对用户体验来说，高可用性十分关键，大多数应用对时延的要求是$20ms$以内。因此，$PaxosStore$需要在满足高吞吐率的同时，保持不同服务结点之间的数据一致性。
	\par $PaxosStore$整体架构包含三层：编程模型，一致，存储。编程模型提供了不同的数据结构给用户，一致层实施了基于$Paxos$算法的存储协议。存储层包含了使用不同存储模型的存储系统。

\section{$PaxosStore$一致层的实现}
	\par 传统$Paxos$算法包含两个阶段，$Prepare$阶段初步达成一致，$accept$阶段达成最终共识。按照惯例，$Paxos$算法的过程是使用状态机来描述的，但是，过多不必要的状态以及复杂的状态迁移不但加剧了实现的复杂性，也造成了运行时的低效。于是$PaxosStore$放弃了基于状态机的实现，而是采用半对称消息传递来实施$Paxos$算法。
	\par $PaxosStore$中，定义一个提议$P$为
\begin{align*}
P=(n,v) 
\end{align*}
	\par 其中$n$是提议号，$v$是提议值。$N_X$代表一个结点，结点号为$X$，$r$是一个数据记录，$r_X$是$r$在$N_X$处的副本。令$S_X^Y$作为$r_Y$在$N_X$处的状态，定义为
\begin{align*}
S_Y^X=(m,P)
\end{align*}
	\par 其中$m$是$r_Y$保证接受的最小提议号，$P$是$r_Y$最近接受的提议。换句话说，任何提议，如果其提议号$n<m$	，将会被$r_Y$拒绝。特别地，将$S_Y^X(X\neq Y)$作为观察状态，$S_X^X$作为真实状态。主义观察状态与真实状态在一些情形下可能不同，同步化这些状态依赖于$Paxos$算法。
	\par 在$PaxosStore$中，数据副本间的共识是通过互相交换观察状态与真实状态达到的，相关的消息
\begin{align*}
M_{X\rightarrow Y}=\{S_X^X, S_Y^X\}
\end{align*}
	\par 也就是说，结点$N_X$将$r_X$的真实状态以及它对$r_Y$的观察状态发送给$N_Y$。不像$Paxos$其他使用多种消息的实现，$PaxosStore$使用如上定义的唯一一种消息。

\begin{algorithm}
\DontPrintSemicolon % Some LaTeX compilers require you to use \dontprintsemicolon instead
\caption{Paxos implementation in PaxosStore}
\label{alg:PaxosStore}

  \SetKwFunction{is}{Issue}\SetKwFunction{omes}{OnMessage}\SetKwFunction{upd}{UpdateStates}
  \SetKwFunction{isc}{IsValueChosen}
  \SetKwProg{mpr}{Procedure}{}{}
  \SetKwProg{mf}{Function}{}{}

  \KwIn{intention proposal number $m_i$}
  \mpr{\is{$m_i$}}{
  	$S_A^A\leftarrow$ actual state of $r_A$ \;
  	\If{$S_A^A.m<m_i$}{
		$S_A^A.m\leftarrow m_i$ \;
		write $S_A^A$ to the PaxosLog entry of $r_A$ \;
		\ForEach  {remote replica node $N_X$}{
			send $M_{A\rightarrow X}$
		}
	}
  }

  \KwIn{proposal $P_i$ with $P_i.n = m_i$ }
  \mpr{\is{$P_i$}}{
  $S_A^A\leftarrow$ actual state of $r_A$ \;
  $S^A\leftarrow$ all the states of $r$ matained at $N_A$ \;
  \If{$\lvert \{ \forall S_X^A\in S^A\mid S_X^A.m=P_i.n\}\lvert \times 2 > |S^A| $}{
	\If{$\lvert \{ \forall S_X^A\in S^A\mid S_X^A.P.v\neq null\}\lvert > 0 $}{
		$P'\leftarrow$ the proposal with maximum $P.n$ in $S^A$\;
		$S_A^A.P\leftarrow (P_i.n, P'.v)$
	}
	\Else{
		$S_A^A.P\leftarrow P_i$
	}
	write $S_A^A$ to the PaxosLog entry of $r_A$ \;
	\ForEach  {remote replica node $N_X$}{
		send $M_{A\rightarrow X}$
	}
  }
  \KwRet\;
  }
\KwIn{message $M_{X\rightarrow Y}$sent from $N_X$ to $N_Y$}
\mpr{\omes{$M_{X\rightarrow Y}$}}{
	$S_X^X$,$S_Y^X\leftarrow M_{X\rightarrow Y}$\;
	UpdateStates($Y$,$S_X^X$)\;
	\If {$S_Y^Y$ is changed}{
		write $S_Y^Y$ to the PaxosLog entry of $r_Y$\;
		\lIf{ IsValueChosen($Y$) is $true$}{
			commit\;
		}
	}
	\If {$S_Y^X<S_Y^Y.m$ or $S_Y^X.P.n<S_Y^Y.P.n$}{
		send $M_{Y\rightarrow X}$\;
	}
}
\KwIn{node ID $Y$, actual state $S_X^X$ of $r_X$}
\mf{\upd { Y,$S_X^X$ } }{
	$S_X^Y\leftarrow$ view state of $r_X$stored in $N_Y$ \;
	$S_Y^Y\leftarrow$ actual state of $r_Y$ \;
	\lIf {$S_X^Y.m<S_X^X.m$} {      $S_X^Y.m\leftarrow S_X^X.m$ }
	\lIf {$S_X^Y.P.n<S_X^X.P.n$} {  $S_X^Y.P\leftarrow S_X^X.P$ }
	\lIf {$S_Y^Y.m<S_X^X.m$} {      $S_Y^Y.m\leftarrow S_X^X.m$ }
	\lIf {$S_Y^Y.m\leq S_X^X.P.n$}{ $S_Y^Y.P\leftarrow S_X^X.P$ }
}
\end{algorithm}
\begin{algorithm}
\SetKwFunction{is}{Issue}\SetKwFunction{omes}{OnMessage}\SetKwFunction{upd}{UpdateStates}
  \SetKwFunction{isc}{IsValueChosen}
  \SetKwProg{mpr}{Procedure}{}{}
  \SetKwProg{mf}{Function}{}{}

\KwIn{node ID $Y$}
\KwOut{whether the proposals in $N_Y$ form a majority}
\mf{\isc{$Y$}}{
	$S^Y\leftarrow$all the states of $r$ maintained at $N_Y$\;
	$n'\leftarrow$occurrence count of the most frequent $P.n$ in $S^Y$\;
	\Return {$n'\times2>|S^Y|$}
}
\end{algorithm}
			
	\par $Algorithm$\ref{alg:PaxosStore} 总结了$Paxos$算法在$PaxosStore$中的实现。最初，当一个结点$N_A$收到一个写请求，它唤起$Issue(m_i)$开始准备阶段，其中$m_i$是结点定义的提议号。$N_A$把$r_A$的真实状态以及$r_X$的观察状态发送给所有其他结点$N_X$。一个结点不论何时收到消息，函数$OnMessage()$会被唤起使用接收到其他结点的消息来更新本地状态($UpdateStates()$)。除过更新结点的状态，$OnMessage()$通过判断是否达到大多数进程接受的标准来检测提议值是否被选择。如果更新过的结点本地状态被判断为是最新的接收结点会把其本地状态发送回去。
	\par 注意如果$N_A$发起的提议号$m_i$在超时后仍没有达到多数进程接受，$N_A$会使用一个更大的提议号$m_{i'}$唤起$Issue(m_{i'})$。只有在规定的时间内被大多数进程所接受，$N_A$才会唤起$Issue(P_i)$开始第二阶段，其中$P_i.n=m_i$,$P_i.v$是用户写请求给定的值。相同的过程在大多数进程接受的条件满足之前重复进行。
	\par 统一处理例程不断启动$Paxos$算法，直到最终的共识达成。这不但简化了$Paxos$的实施，也有利于进程在本地处理消息。
	\par 虽然$PaxosStore$已经被腾讯公司广泛部署，提供了微信的后台支撑，但是其正确性有待证明。

\section{$PaxosStore$中$Paxos$部分的正确性证明}
	\par 为了证明$PaxosStore$的正确性，我们试图将$PaxosStore$与$Lamport$的经典$Paxos$算法做一个一一映射，这样通过$Lamport Paxos$算法的正确性，就可以证明$PaxosStore$的正确性。
\begin{enumerate}
\item
	\par 首先，$PaxosStore$使用消息传递来进行本地变量副本的修改，我们假定消息在传递的过程中不会出错，也就是不会发生$Byzantine$错误，传递的消息可能会因为丢包、超时等没有被接收到，但是接收到的包一定不会出错。
\item
	\par 其次，证明本地副本的有效性。$S_A,S_B^A$的定义见之前对$PaxosStore$的描述。这里将本地副本$S_B^A.m$初始化为0，$S_B^A.P$初始化为$null$。为了证明$S_A$的有效性，我们分类讨论$S_B^A$中$A$与$B$的关系。
	\begin{enumerate}
	\item $A==B$，$S_A^A.m$存储的是A本地信息，有效性显然。
	\item $A\ne B$，对$S_B^A.m$与$S_B^B.m$分情况讨论
		\begin{enumerate}
		\item $S_B^A.m = S_B^B.m$，则$S_B^A$代表了$B$的真实状态，有效性显然。
		\item $S_B^A.m < S_B^B.m$，则此对应经典$Paxos$算法运行过程中，进程间通信时，由于时延或者丢包导致的结点间信息不一致。这种不一致性不会影响$Paxos$算法的正确性，因为$S_B^A.m$一定是由$B$传递给$A$的，代表$B$状态的历史版本，$Paxos$算法允许这样的情况出现。
		\item $S_B^A.m > S_B^B.m$，则一定存在消息$M_{B\rightarrow A}$，且此消息中$B$的提议号为$S_B^A.m$，$B$一定由消息中包含的提议号$S_B^A.m$更新过自己的状态。则$B$的真实状态包含的提议号$m>=S_B^A.m$，矛盾。
		\end{enumerate}
	\end{enumerate}
\end{enumerate}
	\par 由于结点$A$在更新$S_B^A.m$时，会同时更新$S_B^A.P$，因此$S_B^A$在整个$PaxosStore$算法运行过程中始终有效。
	\par 因此，$PaxosStore$中每个结点访问的本地存储都是有效的，都代表了其余结点在当前或者以前某一时刻的状态，经典$Paxos$算法的正确性保证了$PaxosStore$算法的正确性。
	

