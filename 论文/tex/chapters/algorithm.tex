\chapter{分布式优先级队列\\设计与分析}
\label{chapter:algorithm}
\par 本章将具体探讨分布式优先级队列的算法设计、数据一致性分析。首先，将给出一种比较高效的分布式优先级队列的算法设计，包括消息定义、客户端节点算法以及服务端节点算法，并简要分析其性能。之后，将会从带时钟、以及不带时钟两个方向，分析分布式优先级队列的数据一致性。
\section{算法设计}
	\label{section:algorithm}
	\par 本节将给出一种分布式优先级队列的算法设计。设计分布式优先级队列，主要的设计点在于：客户端如何处理来自上层应用的操作，服务端如何处理来自上层应用的操作；客户端和服务端之间要如何维护彼此的RPQ的一致。
	\subsection{通信协议}
		\label{section:protocol}
		\par 首先要确立客户端和服务端之间通信的消息类。分析同步算法的流程，服务端与客户端之间的消息类型有：
		\begin{itemize}
			\item 与RPQ操作相关的消息，主要由客户端向服务端发送。
			\begin{itemize}
				\item $alter\left\langle x,n\right\rangle $，由客户端发向服务端，表示客户端进行了一次alter操作，将x元素的优先级设置为n。
				\item $delta\left\langle x,d\right\rangle $，由客户端发向服务端，表示客户端将$x$的优先级增加了$d$。
				\item $insert\left\langle e\right\rangle $，由客户端发向服务端，表示客户端新插入一个元素$e$。
				\item $delete\left\langle x,n,f\right\rangle $，由客户端发向服务端，表示客户端请求删除并获取当前RPQ顶端的元素；由服务端发向客户端表示当前删除了元素$x$，它的最终优先级为$n$，$f$表示是否由目标客户端获取了这个元素。
			\end{itemize}
			\item 与同步相关的消息$update\left\langle S\right\rangle $，$S$是一个集合，集合内部有若干条内容$c\left\langle x,n\right\rangle $，表示当前更新一个元素$x$，其最新优先级为$n$。
		\end{itemize}
	\subsection{客户端}
		\begin{table}
			\begin{center}
				\begin{tabular}{r|l}		
					\hline
					符号 & 解释 \\
					\hline\hline
					$PriQue^{(c_{k})}$ & 客户端$c_k$本地的优先级队列副本\\
					$MsgQue^{(c_{k})}$ & 客户端$c_k$内的待发送消息队列\\
					$MsgSender^{(c_{k})}$ & 客户端$c_k$的异步消息发送进程\\
					$MsgRcver^{(c_{k})}$ & 客户端$c_k$接收来自服务端消息的进程\\
					\hline
				\end{tabular}
				\caption{客户端算法涉及的主要符号}
				\label{table:client symble}
			\end{center}
		\end{table}
		\par 由\ref{section:struct}节中所探讨的RPQ结构，一个RPQ中可以有多个客户端，记为$c_{0},c_{1},\ldots,c_{n}$。每一个客户端有相同的客户端算法，运行着相同的程序。
		\par 客户端的RPQ需要处理的主要有两者：来自客户端上层应用的操作请求，来自服务端的信息。客户端内部有一个优先级队列的副本，使用异步的消息发送机制。以下将简述客户端RPQ的算法：
		\begin{itemize}
			\item 收到来自上层应用的操作请求：
			\begin{itemize}
				\item $insert\left\langle x,n\right\rangle ,alter\left\langle x,n\right\rangle ,delta\left\langle x,diff\right\rangle $：执行操作后，立即返回，异步的将对应的消息发送给服务器做同步。
				\item $get\_max$：立即返回本地的优先级队列副本中的队首元素。
				\item $delete\_max$：阻塞，向服务器发送$delete$消息。等待服务器返回$f$是$true$的$delete$消息，将该$delete$消息中的内容返回给上层应用。
			\end{itemize}
			\item 收到来自服务器$s$的消息：
			\begin{itemize}
				\item $delete\left\langle x,n,f\right\rangle $：将本地优先级队列副本中的$x$元素删除。如果f为true，则使等待中的上层应用唤醒，将$delete$消息中的内容返回给上层应用。
				\item $update\left\langle S\right\rangle $：对$S$中的每一条内容$c\left\langle x,n\right\rangle $，若$x$存在于本地的优先级队列副本中，则更改本地副本中$x$的优先级为$n$，否则向本地优先级队列插入一个$x$，其优先级为$n$。
			\end{itemize}
		\end{itemize}
		\par 可以看到除了主线程之外，客户端RPQ还有其他的线程。在详述算法之前，表\ref{table:client symble}给出了算法涉及的主要符号。
		\subsubsection{客户端面向应用的RPQ}
			\par 算法\ref{alg:RPQ client}给出了RPQ中client端的算法，它接收并处理来自客户端程序访问、更改RPQ的请求。
			\begin{algorithm}
				\caption{RPQ on $c_k$}
				\label{alg:RPQ client}
				\Begin(Receiving $alter\left\langle x,n\right\rangle $ from app)
				{
					alter $x$'s priority to $n$ in $PriQue^{(c_{k})}$\;
					push $alter\left\langle x,n\right\rangle $ into $MsgQue^{(c_{k})}$\;
				}
				\Begin(Receiving $delta\left\langle x,diff\right\rangle $ from app)
				{
					add $diff$ to $x$'s priority in $PriQue^{(c_{k})}$\; 
					push $delta \left\langle x,diff\right\rangle $ into $MsgQue^{(c_{k})}$\;
				}
				\Begin(Receiving $insert\left\langle x,n\right\rangle $ from app)
				{
					add element $x$ with priority $n$ in $PriQue^{(c_{k})}$\;
					push $insert\left\langle x,n\right\rangle $ into $MsgQue^{(c_{k})}$\;
				}
				\Begin(Receiving $get\_max$ from app)
				{
					\Return the max element in the $PriQue^{(c_{k})}$\;
				}
				\Begin(Receiving $delete\_max$ from app)
				{
					send $delete\left\langle x,n,f\right\rangle $ to server $s$\;
					wait to be invoked by $MsgRcver^{(c_{k})}$\;
					\Return the max element given by $MsgRcver^{(c_{k})}$\;
				}
			\end{algorithm}
		\subsubsection{客户端异步消息发送}
			\par $MsgQue^{(c_{k})}$进程，配合$MsgQue^{(c_{k})}$实现了client端简单的异步消息发送。算法\ref{alg:client send msg}给出了简单的$MsgQue^{(c_{k})}$进程的算法。
			\begin{algorithm}
				\caption{$MsgSender^{(c_{k})}$ on $c_k$}
				\label{alg:client send msg}
				\Begin($MsgQue^{(c_{k})}$ becomes nonempty)
				{
					\While{$MsgQue^{(c_{k})}$ is not empty}
					{
						send the message at the head of the $MsgQue^{(c_{k})}$ to server $s$\;
						pop the head of the $MsgQue^{(c_{k})}$\;
					}
				}
			\end{algorithm}
		\subsubsection{底层与服务端交互}
			\par $MsgRcver^{(c_{k})}$负责在应用层之下处理与服务端之间的通信，透明于上层的应用程序。算法\ref{alg:client recv msg}给出了它的算法。
			\begin{algorithm}	
				\caption{$MsgRcver^{(c_{k})}$ on $c_k$}
				\label{alg:client recv msg}
				\Begin(Receiving $delete\left\langle x,n,f\right\rangle $ from server $s$)
				{
					\If{$x$ is in the $PriQue^{(c_{k})}$}
					{
						delete element $x$ from $PriQue^{(c_{k})}$\;
					}
					\If{$f$=true}
					{
						give the element $x$ and its latest priority $n$ to the app\;
						invoke the app who's waiting for the max element\;
					}
				}
				\Begin(Receiving $update\left\langle S\right\rangle $ from server $s$)
				{
					\ForEach{content $c\left\langle x,n\right\rangle \in S$}
					{
						\If{$x$ is in the $PriQue^{(c_{k})}$}
						{
							alter the priority of $x$ to $n$ in $PriQue^{(c_{k})}$\;
						}
						\Else
						{
							add the element $x$ to $PriQue^{(c_{k})}$, with the priority $n$\;
						}
					}
					\ForEach{element in $PriQue^{(c_{k})}$ that is not changed by update and still on top k level}
					{
						decrease its priority to unknown, such as negative infinity\;
					}
				}
			\end{algorithm}
			\par 下面简要分析一下客户端算法复杂度。首先，对于RPQ的操作，复杂度与传统的优先级队列相同，设优先级队列的大小weight$n$，则操作复杂度为$O(\log_2 n)$，而对于查询max操作，复杂度为$O(1)$。其次，除了delete的操作之外，所有的操作都是立即返回，异步向服务端发送消息而不用等待，故是响应是十分快速的。对于delete操作，设客户端到服务端的通信延迟为$T_m$，而服务端处理客户端delete操作的时间为$T_s$，则delete操作的响应延迟为$delay=T_s+2\times T_m$。
	\subsection{服务端}
		\begin{table}
			\begin{center}
				\begin{tabular}{r|l}		
					\hline
					符号 & 解释 \\
					\hline\hline
					$PriQue^{(s)}$ & 服务端$s$本地的优先级队列\\
					$TaskQue^{(s)}$ & 服务端$s$内元素更改缓存队列\\
					$Applier^{(s)}$ & 服务端$s$暂存任务执行进程\\
					$VersionCtrl^{(s)}$ & 服务端$s$内的版本控制器\\
					$MsgRcver^{(s)}$ & 服务端$s$接来自客户端消息的进程\\
					\hline
				\end{tabular}
				\caption{服务端算法涉及的主要符号}
				\label{table:server symble}
			\end{center}
		\end{table}
		\par 根据\ref{section:struct}节中的RPQ结构，一个RPQ中只有一个服务端，记其为$s$。服务端的RPQ负责数据的整理，以及决定系统整体一致性的维护。
		\par 服务端的RPQ主要有两者需要处理：来自服务端上层应用的操作请求，来自各个客户端的信息。和客户端一样，服务端内部也有一个优先级队列，且是整个RPQ中握有最全面信息的队列。此外，服务端$s$还有控制堆的版本与同步，接受所有客户端的信息，快速汇总的任务。下面将简述服务端RPQ的算法：
		\begin{itemize}
			\item 收到来自上层应用的操作请求：
			\begin{itemize}
				\item $insert\left\langle x,n\right\rangle ,alter\left\langle x,n\right\rangle ,delta\left\langle x,diff\right\rangle $：将操作带来的改变暂存进待进行队列中，立即返回。
				\item $get\_max$：查看待进行队列中未来最大的元素，以及未改变的堆中的最大的元素，返回优先级更大的元素。
				\item $delete\_max$：阻塞，将待进行队列中的所有改变运行过后，删掉本地优先级队列最大的元素$x$，对所有连接的客户端发送$delete\left\langle x,n,\textit{false}\right\rangle $，将被删除的元素返回给上层。
			\end{itemize}
			\item 收到来自客户端$c_k$的消息：
			\begin{itemize}
				\item 初始连接：将版本控制器指定的当前堆的部分，打包为$update\left\langle S\right\rangle $发送给$c_k$。
				\item $insert\left\langle x,n\right\rangle ,alter\left\langle x,n\right\rangle ,delta\left\langle x,diff\right\rangle $：将数据指示的操作带来的改变暂存进待进行队列中。
				\item $delete\_max$：阻塞，将待进行队列中的所有改变运行过后，删掉本地优先级队列最大的元素$x$，对$c_k$发送发送$delete\left\langle x,n,\textit{true}\right\rangle $，对所有其他连接的客户端发送$delete\left\langle x,n,\textit{false}\right\rangle $。
			\end{itemize}
			\item 优先级队列的待运行队列，对同一个元素以新的写覆盖旧的写，时刻尽最大努力将自己暂存的改变写入在本地的优先级队列。写入的时候向版本控制记录本次操作。
			\item 版本控制器，每次本地优先级队列有改变的时候，编码本次改变为版本的增加。在版本增加到一定限度后，选择合适的堆的部分，打包为$update\left\langle S\right\rangle $发送给所有连接的客户端。
		\end{itemize}
		\par 下面将详述服务端RPQ的算法。表\ref{table:server symble}给出了算法涉及的主要符号。
		\subsubsection{服务端面向应用的RPQ}
			\par 算法\ref{alg:RPQ server}给出了RPQ中server端的算法，它接收并处理来自服务端程序访问、更改RPQ的请求。此外，他也给出了$TaskQue^{(s)}$中，对于同一个元素，合并未完成的操作以减少最终在本地RPQ中操作的方法。
			\begin{algorithm}
				\caption{RPQ on $s$}
				\label{alg:RPQ server}
				\Begin(Receiving $alter\left\langle x,n\right\rangle $ from app)
				{
					\If{x is in $TaskQue^{(s)}$}
					{
						change $x$'s future priority in $TaskQue^{(s)}$ to $n$\;
					}
					\Else
					{
						add $x$ and its future priority $n$ into $TaskQue^{(s)}$\;
					}
				}
				\Begin(Receiving $delta\left\langle x,diff\right\rangle $ from app)
				{
					\If{x is in $TaskQue^{(s)}$}
					{
						add $diff$ to $x$'s future priority in $TaskQue^{(s)}$\;
					}
					\Else
					{
						add $x$ and its future priority $x.priority+diff$ into $TaskQue^{(s)}$\;
					}
				}
				\Begin(Receiving $insert\left\langle x,n\right\rangle $ from app)
				{
					add element $x$ with future priority $n$ in $TaskQue^{(s)}$\;
				}
				\Begin(Receiving $get\_max$ from app)
				{
					$x:=$ the max element in the $PriQue^{(s)}$ without future priority\;
					$y:=$ the element in $TaskQue^{(s)}$ with highest future priority\;
					\Return Max($x$,$y$)\;
				}
				\Begin(Receiving $delete\_max$ from app)
				{
					block and excecute each task $t$ in $TaskQue^{(s)}$\;
					$x:=$ the max element in the $PriQue^{(s)}$, whose priority is $n$\;
					send $delete\left\langle x,n,\textit{false}\right\rangle $ to each client connected to $s$\;
					delete $x$ from $PriQue^{(s)}$\;
					\Return $x$\;
				}
			\end{algorithm}			
		\subsubsection{底层与客户端交互}
			\par 在服务端的视角上，上层的应用和远程连接的客户端基本可以视作是相同的；可以说，上层的应用也可以看做一个客户端。因此，底层与客户端交互的算法大致与服务端RPQ与上层应用交互相同。值得注意的是，比如由于客户端$c_k$的RPQ在$get\_max$的时候，是查看本地的$PriQue^{(c_k)}$的最高优先级元素的，因此服务端不会收到来自客户端的$get\_max$信息的；此外，$delete\_max$消息的处理也略有不同。
			\par 算法\ref{alg:server recv msg}给出了服务端在底层与客户端RPQ交互的算法。
			\begin{algorithm}
				\caption{$MsgRcver^{(s)}$ on $s$}
				\label{alg:server recv msg}
				\Begin(Initialize)
				{
					send a part of $PriQue^{(s)}$, designated by $VersionCtrl^{(s)}$, packed as $update\left\langle S\right\rangle $ to $c_k$\;
				}
				\Begin(Receiving $alter\left\langle x,n\right\rangle $ from $c_k$)
				{
					\If{x is in $TaskQue^{(s)}$}
					{
						change $x$'s future priority in $TaskQue^{(s)}$ to $n$\;
					}
					\Else
					{
						add $x$ and its future priority $n$ into $TaskQue^{(s)}$\;
					}
				}
				\Begin(Receiving $delta\left\langle x,diff\right\rangle $ from $c_k$)
				{
					\If{x is in $TaskQue^{(s)}$}
					{
						add $diff$ to $x$'s future priority in $TaskQue^{(s)}$\;
					}
					\Else
					{
						add $x$ and its future priority $x.priority+diff$ into $TaskQue^{(s)}$\;
					}
				}
				\Begin(Receiving $insert\left\langle x,n\right\rangle $ from $c_k$)
				{
					add element $x$ with future priority $n$ in $TaskQue^{(s)}$\;
				}
				\Begin(Receiving $delete\_max$ from $c_k$)
				{
					block and excecute each task $t$ in $TaskQue^{(s)}$\;
					$x:=$ the max element in the $PriQue^{(s)}$, whose priority is $n$\;
					delete $x$ from $PriQue^{(s)}$\;
					send $delete\left\langle x,n,\textit{true}\right\rangle $ to $c_k$\;
					send $delete\left\langle x,n,\textit{false}\right\rangle $ to all other clients connected to $s$\;
				}
			\end{algorithm}
		\subsubsection{暂存任务的执行}
			\par 服务端RPQ与客户端的RPQ有一点不同，即服务端的RPQ在接到来自上层应用，或者来自客户端的消息来插入元素、更改队列中元素优先级的时候，不会立即执行这条操作，而是将其暂存进队列中，将来执行。
			\par 引入这样的设计的原因在于，服务端作为RPQ的中心节点，其性能可能会成为整个系统的瓶颈，因此引入这样的设计来提高服务端处理的吞吐量，具体见算法分析部分。
			\par $TaskQue^{(s)}$是服务端RPQ中的任务暂存队列，对其的写入体现在之前算法\ref{alg:RPQ server}、算法\ref{alg:server recv msg}中。$Applier^{(s)}$是暂存任务的执行进程，算法\ref{alg:server applier}给出了它的算法描述。
			\begin{algorithm}
				\caption{$Applier^{(s)}$ on $s$}
				\label{alg:server applier}
				\Begin($TaskQue^{(s)}$ becomes nonempty)
				{
					\While{$TaskQue^{(s)}$ is not empty}
					{
						wait until the server is not busy or $Applier^{(s)}$ have waited for too long\;
						$\left\langle x,n\right\rangle :=$ the head of $TaskQue^{(s)}$\;
						pop the head of $TaskQue^{(s)}$\;
						\If{$x$ is in $PriQue^{(s)}$}
						{
							alter its priority to $n$ in $PriQue^{(s)}$\;
						}
						\Else
						{
							insert an element $x$ with priority $n$ into $PriQue^{(s)}$;
						}
						tell $VersionCtrl^{(s)}$ about this operation\;
						\If{$VersionCtrl^{(s)}$ tells that an update is needed}
						{
							send a part of $PriQue^{(s)}$, designated by $VersionCtrl^{(s)}$, packed as $update\left\langle S\right\rangle $ to each client connected to $s$\;
							tell $VersionCtrl^{(s)}$ that an update has been done\;
						}
					}
				}
			\end{algorithm}
		\subsubsection{版本控制}
			\par 服务端RPQ作为更新的决定者，其决定的依据由服务端的$VersionCtrl^{(s)}$给出。
			\par $VersionCtrl^{(s)}$是RPQ内的版本控制器，控制服务端RPQ、客户端RPQ副本的版本差异。通过得知服务端RPQ的每一次操作，以此为信息来不断维护RPQ的当前版本。并在适当的时候，告知服务端是否需要更新，以及如何更新。
			\par $VersionCtrl^{(s)}$是一个抽象的概念，它可以有多种实现方法，但是各种实现有以下的共性：
			\begin{itemize}
				\item 每次服务端RPQ被操作之后，$VersionCtrl^{(s)}$都要获知此次操作的信息，比如本次操作最高涉及到了RPQ中的哪一层，以及操作后RPQ的大小等。
				\item 在一次更新完成后，能重置版本控制。
				\item 在获知了信息后，能够确定、或者动态确定版本差异的最大值，服务端的RPQ的版本达到一定阈值之后要可以告知需要更新。
				\item 在获知了信息后，能够确定、或者动态确定如果要更新，更新服务端RPQ的哪一部分。
				\item 考虑优先级队列，读中最重要的是对max元素的读取，因此合理的$VersionCtrl^{(s)}$应该能够有一个性质：更新的时候队首元素一定会被更新，如果队首元素发生了变化则一定会触发更新。
			\end{itemize}
			\par $VersionCtrl^{(s)}$有多种实现方式，下面将介绍几种典型的实现。
			\paragraph{max版本控制}
				\par 这是一种十分简单的版本控制，只关注RPQ中的max元素，只更新max元素。算法\ref{alg:Root-VersionCtrl}简要的描述了它的update步骤。
				\begin{algorithm}
					\caption{update of Root-VersionCtrl}
					\label{alg:Root-VersionCtrl}
					\KwIn{$size$ of the $PriQue^{(s)}$, the highest affected $level$}
					\If{$level=0$}{note that an update is needed}
				\end{algorithm}
			\paragraph{线性版本控制} 除了影响到max元素的操作外，版本以线性速度增长。维护阈值$threshold$、要更新的元素层数$k$、版本数$version$，当$version>threashold$时，更新队列的前$k$层。关键update步骤在算法\ref{alg:Linear-VersionCtrl}描述。
				\begin{algorithm}
					\caption{update of Linear-VersionCtrl}
					\label{alg:Linear-VersionCtrl}
					\KwIn{$size$ of the $PriQue^{(s)}$, the highest affected $level$}
					$k:=\sqrt[2]{\log_2 size}$\;
					$threshold:=\log_2 size$\;
					\If{$level=0$}
					{
						$version:=version+threshold$\;
					}
					\ElseIf{$level<k$}
					{
						$version=version+(k-level)$\;
					}
				\end{algorithm}
			\paragraph{指数版本控制} 除了影响到max元素的操作外，版本以层数速度增长。维护阈值$threshold$、要更新的元素层数$k$、版本数$version$，当$version>threashold$时，更新队列的前$k$层。关键update步骤在算法\ref{alg:Exp-VersionCtrl}描述。
				\begin{algorithm}
					\caption{update of Exp-VersionCtrl}
					\label{alg:Exp-VersionCtrl}
					\KwIn{$size$ of the $PriQue^{(s)}$, the highest affected $level$}
					$k:=\sqrt[2]{\log_2 size}$\;
					$threshold:=2^k$\;
					\If{$level=0$}
					{
						$version:=version+threshold$\;
					}
					\ElseIf{$level<k$}
					{
						$version=version+2^{k-level}$\;
					}
				\end{algorithm}
			\paragraph{} 此外还可以有很多其他的版本控制设计。综合上面列举的几种版本控制设计，可以总结出RPQ中$VersionCtrl^{(s)}$的设计的共同特点，即核心为3个要素的设计：
			\begin{enumerate}
				\item 阈值$threshold$随$PriQue^{(s)}$的大小的变化，记为函数$f(size)$。
				\item 关注层数$k$随$PriQue^{(s)}$的大小的变化，记为函数$g(size)$。
				\item 版本号$version$在最高受影响层数$level!=0\bigwedge level<k$的情况下 的增量，记为函数$h(k,level)$。
			\end{enumerate}
			\par 在有了$f(size)$、$g(size)$、$h(k,level)$后，可以定义出$VersionCtrl^{(s)}$的设计框架：维护阈值$threshold$、要更新的元素层数$k$、版本数$version$，当$version>threashold$时，更新队列的前$k$层。关键update步骤在算法\ref{alg:Framework-VersionCtrl}描述。
			\begin{algorithm}
				\caption{Framework of update of VersionCtrl}
				\label{alg:Framework-VersionCtrl}
				\KwIn{$size$ of the $PriQue^{(s)}$, the highest affected $level$}
				$k:=f(size)$\;
				$threshold:=g(size)$\;
				\If{$level=0$}
				{
					$version:=version+threshold$\;
				}
				\ElseIf{$level<k$}
				{
					$version=version+h(k,level)$\;
				}
			\end{algorithm}
			\par 于是上面的max版本控制、线性版本控制、指数版本控制可以总结见表\ref{table:Framework-VersionCtrl}。可以看到，不同的3种函数，带来了3种不同的版本控制实现。
			\begin{table}			
				\begin{center}
					\begin{tabular}{c|ccc}
						&$f(size)$&$g(size)$&$h(k,level)$\\
						\hline
						max版本控制&$0$&$1$&$0$\\
						线性版本控制&$\sqrt[2]{\log_2 size}$&$\log_2 size$&$k-level$\\
						指数版本控制&$\sqrt[2]{\log_2 size}$&$2^{\sqrt[2]{\log_2 size}}$&$2^{k-level}$\\
					\end{tabular}
				\end{center}			
				\caption{版本控制归纳}
				\label{table:Framework-VersionCtrl}
			\end{table}
			\par $VersionCtrl^{(s)}$有多种实现方式，不同的实现有各自的特点，有各自的适用场景，也对应于各种不同的RPQ为中心的数据一致性定义，详见\ref{section:analysis}节中关于数据一致性的探讨。
			\par 下面简要分析一下服务端的性能。假设$TaskQue^{(s)}$的长度为$l$，$PriQue^{(s)}$的大小为$n$，而连接了$k$个客户端。
			\par 首先，易见版本控制每次调用的复杂度为$O(1)$。而对于insert，delta，alter操作，由于是将操作暂存在$TaskQue^{(s)}$中，故单次操作的复杂度为$O(1)$，而在之后是有调整的复杂度的。
			\par 对于将$TaskQue^{(s)}$中的改变应用到$PriQue^{(s)}$中，单次的操作为一次堆维护操作，设堆的大小为$n$，则其复杂度为$O(\log_2 n)$。$TaskQue^{(s)}$若使用散列表的方式实现，则其操作复杂度为$O(1)$。
			\par 查询max操作的分析比较复杂，在最差情况下，$PriQue^{(s)}$中前$k$大的元素都已经被记录为将会被更改，即都出现在$TaskQue^{(s)}$中，则在$PriQue^{(s)}$中找max元素需要额外的$2\times l$的操作。于是，最差情况下，查询max操作复杂度为$O(l\times 3)=O(l)$。而在最好情况下，$PriQue^{(s)}$中的max元素没有被更改，故从$PriQue^{(s)}$找最大的未被更改元素复杂度为$O(1)$，故查询max操作的复杂度为$O(l)$。
			\par delete操作，需要将$TaskQue^{(s)}$清空，并且需要通知所有的客户端。通知客户端不需要计入消息发送的时间，因为消息不需要等待。综上，delete操作的时间复杂度为$O(l\times \log_2 n +k)$。
			\par 引入$TaskQue^{(s)}$，是为了能够合并对相同的元素的操作，减少最终调整$PriQue^{(s)}$的次数，以提高服务端的吞吐率。假设有比率为$r$的alter，delta，insert操作被合并了，那么服务端的吞吐率就提高到了之前的$\frac{1}{1-r}$，即平均而言，alter，delta，insert的最终复杂度为$O((1-r)\times\log_2 n)$。
\section{数据一致性分析}
	\label{section:analysis}
	\par 本节将会分析设计的RPQ的数据一致性。对于数据一致性的分析将会从带绝对时间、不带绝对时间两个角度进行切入。
	\subsection{不带绝对时间}
		\par 在不带绝对时间的数据一致性模型中，从强到弱有：Atomicity，Sequential Consistency，Causal Consistency，PRAM Consistency\cite{Steinke:2004:UTS:1017460.1017464}。下面我们将主要探讨Sequential Consistency和PRAM Consistency这两个一致性模型。
		\subsubsection{RPQ Sequential-Consistency}
			\par 首先我们回顾一下经典的顺序一致性(Sequential Consistency)\cite{lamport1979make}\cite{Attiya:1994:SCV:176575.176576}\cite{attiya2004distributed}。顺序一致性是一个强一致性模型。通俗的讲，顺序一致性指的是在一个分布式系统中，假设有各个节点$p_0,p_1,\dots,p_n$，他们有一个共享的变量$x$，每一个节点会对$x$进行读写操作。在保证程序顺序的情况下，假设对于每一个节点，对于他们所有的操作，都存在一个排列，使得每个节点看到的序列是相同的，并且每个节点的读都能读到最新的$x$。
			\par 以下是形式化的定义。在一个分布式系统中，对于每一个节点，它的操作都包含两个事件：一个调用事件(invocation)，一个响应事件(response)。对于一个读操作，假设其读的元素为key，那么调用事件记为\textit{read(key)}，响应事件记为\textit{ack(value)}，返回一个值value。对于一个写操作，调用事件记为\textit{write(key,value)}，他的响应事件记为一个单独的\textit{ack}，表明写操作完成。假设有一个全局的逻辑时钟，并且所有的事件都有一个自己的唯一的逻辑时间戳。假设对于所有的共享变量，在逻辑时间开始的时候，有一个写操作为期写入其初始值。
			\par 对于一个分布式系统来说，一个操作序列$\sigma$是一个调用事件、响应事件的序列。一个操作$o_1$先于(precede)另一个操作$o_2$发生，当且仅当在$\sigma$中，$o_1$的响应事件在$o_2$的调用事件之前发生。如果$o_1$不先于$o_2$发生，且$o_2$也不先于$o_1$发生，那么它们就是并发的(concurrent)。如果对于每一个节点$p_i$，$\sigma |i$（$\sigma$中发生在$p_i$中的子操作序列）是由一组组成对出现的，以调用事件开始的调用事件、响应事件对，那么就说操作序列$\sigma$是良结构的(well-formed)。一个操作序列$\sigma$是序列化的(sequential)如果：1、$\sigma$是良结构的而且2、对于$\sigma$上的每一个操作，一个调用事件后面将紧跟着它的响应事件。
			\begin{definition}
				\textbf{顺序一致性(Sequential-Consistency)} 一个分布式系统满足顺序一致性，如果对于每个它的良结构的操作序列$\sigma$，对于$\sigma$的所有的操作，存在一个排列$\pi$使得：
				\begin{enumerate}
					\item $\pi$是序列化的。
					\item $\pi$中的每一个读操作，将会返回$\pi$中对于被读对象最近执行的写操作写入的值，如果没有的话则会返回这个元素的初始值。
				\end{enumerate}
			\end{definition}
			\par 以上是经典的顺序一致性。在分析RPQ的数据一致性保障时，需要对其略为修改来适用于这个场景。
			\par RPQ是一个分布式数据结构而不是一个分布式共享变量，共享变量的操作有两个：read，write。RPQ的操作有：insert，alter，delta，get\_max，delete\_max。那么，继承经典的顺序一致性，RPQ的每一个操作都有其对应的调用事件和响应事件，且他们都有自己唯一的逻辑时间戳。一个操作序列一个操作序列$\sigma$是序列化的(sequential)定义与经典顺序一致性相同。
			\begin{definition}
				\textbf{RPQ顺序一致性(RPQ Sequential-Consistency)} 一个RPQ满足顺序一致性，如果对于每个它的良结构的操作序列$\sigma$，对于$\sigma$的所有的操作，存在一个排列$\pi$使得：
				\begin{enumerate}
					\item $\pi$是序列化的。
					\item $\pi$中的每一个get\_max以及delete\_max操作，将会返回$\pi$中位于该操作之前的所有的insert，alter，delta，delete\_max操作依照$\pi$中的顺序执行完后，而$\pi$中位于该操作之后的操作都没有执行时，RPQ中有最高优先级的元素，如果RPQ是空的，返回空值。
				\end{enumerate}
			\end{definition}
			\par 注意到我们将视角放在了优先级队列的核心语义：max元素上面。对于不是max元素的其他元素，RPQ Sequential-Consistency并不关注。
			\par 下面将分析我们设计的RPQ是否满足RPQ Sequential-Consistency。 
			\begin{theorem}
				在\ref{section:algorithm}节中设计的RPQ，在只出现insert，alter，delta，delete\_max操作，而没有get\_max操作的时候，满足RPQ Sequential Consistency。
			\end{theorem}
			\begin{proof}
				首先，由于客户端、服务端之间的通信是FIFO的，而根据\ref{section:algorithm}节中设计的算法，易见对于服务端，其上的所有操作，以及所有接受的的客户端的操作组成的操作序列$\sigma$是序列化的。其次，由于get\_max操作，无论是服务端或者客户端进行，都会触发服务端上面$PriQue^{(s)}$，$TaskQue^{(s)}$上锁，由于服务端是中心节点最终全局看到的试图是由服务端提供的，于是就意味着全局被上锁。所以可以保证delete\_max操作，所获得的元素是执行完所有之前的操作、之后的操作都没有执行时候RPQ中的最大值，或者在RPQ为空时，空值。
			\end{proof}
			\begin{theorem}
				在\ref{section:algorithm}节中设计的RPQ，不满足RPQ Sequential Consistency。
			\end{theorem}
			\begin{proof}
				由于get\_max是立即读本地的副本中的最大元素。考虑一个简单的情况，只有一个服务端$s$和一个客户端$c_0$。此时堆里有一个元素$a=10$。它们进行了如下的操作：
				\begin{center}
					$s$：$a^s:alter(a,10), g^s_0:get\_max(), g^s_1:get\_max()$\\
					$c_0$：$a^{c_0}:alter(a,20), g^{c_0}_0:get\_max(), g^{c_0}_1:get\_max()$
				\end{center}
				假设$a^{c_0}$没有及时的传到服务器，而$a^s$没有及时传到客户端，于是$g^s_0=(a,10),g^{c_0}_0=(a,20)$，而之后互相的消息到了之后，$g^s_1=(a,20),g^{c_0}_1=(a,10)$，视图发生了不一致。
			\end{proof}
		\subsubsection{k-RPQ PRAM-Consistency}
			\par 首先我们先回顾一下经典的PRAM一致性。PRAM一致性模型是一个经典的弱一致性模型\cite{lipton1988pram}\cite{Steinke:2004:UTS:1017460.1017464}。通俗的讲，一个分布式系统中若干节点对一个共享对象的读写操作，如果说每一个节点的写操作的顺序在其他节点上都是不变的，那么这个系统的对这个共享对象的读写就满足PRAM一致性。
			\par PRAM一致性属于弱一致性，因为它不需要所有的进程都能够达成共识，对于对共享变量的读写操作产生一个相同的视图，因此每一个进程可以独自检查是否符合PRAM一致性。对于每一个进程而言，它能看到所有其他进程的写操作，而其他所有进程的读操作对它而言是透明的。
			\par 下面形式化的定义PRAM一致性。一个分布式系统有节点$p_0,p_1,\dots,p_n$，$O_i$为节点$p_i$的可见操作的集合，即由所有节点的写操作以及$p_i$的读操作组成。
			\begin{definition}
				\textbf{(PRAM Consistency)}。一个分布式系统的读写操作满足PRAM一致性，当且仅当对于所有的$O_i$，对于$O_i$中的操作存在一个排列$\pi$，使得：
				\begin{enumerate}
					\item $\pi$中的所有的读操作，读到的都是$\pi$中之前最进的对该元素的写操作写入的值。
					\item $\pi$中所有来自同一节点的操作，在$\pi$中的顺序与他们最初的程序顺序一致。
					\item $\pi$中所有的读操作，都存在唯一的写操作与之对应，即目标对象相同，且读的值与写入的值相同
				\end{enumerate}
			\end{definition}
			\par 上面是经典的PRAM一致性模型。在分析RPQ的数据一致性保障时，需要对其略微修改来适用于这个场景。
			\par 与顺序一致性时候的分析一样，RPQ作为一个分布式数据结构，有他自己独特的关注点，在于max元素。在这里，我们将RPQ的关注点放大到关注RPQ在触发同步那一时刻的前k层的所有元素。形式化的定义为，在RPQ部署在的分布式系统中，将节点$c$也抽象为一个普通的节点，$O_i$表示为节点$p_i$中，节点$p_i$的所有操作并上自上次同步以来，整个系统对上次同步的所有元素所做的所有操作的集合。出去$O_i$的定义不同，k-RPQ PRAM-Consistency的定义与经典的PRAM一致性定义相同。
			\par 如此定义$O_i$是因为，在服务端进行同步之前，一个客户端$c_i$是看不到其它节点的操作的，而且在服务端进行了一次同步之后，$c_i$也只能看到所同步的所有元素的操作历史，因此对于$c_i$而言，其能看到的操作是受限的。
			\par 下面将分析我们设计的RPQ对于k-RPQ PRAM-Consistency的满足情况。
			\begin{theorem}
				在\ref{section:algorithm}节中设计的RPQ，满足k-RPQ PRAM-Consistency。
			\end{theorem}
			\begin{proof}
				证明将从两方面考虑：
				\begin{itemize}
					\item 服务端。由于消息传递是FIFO的，服务端$s$收到来自所有客户端的操作的顺序，符合各个客户端内的程序序。易见服务端是满足k-RPQ PRAM-Consistency的。
					\item 客户端。由于客户端$c_i$知晓其他客户端的操作来源于服务端的同步，而由于服务端满足k-RPQ PRAM-Consistency，易见故客户端满足k-RPQ PRAM-Consistency。
				\end{itemize}
				综上，在\ref{section:algorithm}节中设计的RPQ，满足k-RPQ PRAM-Consistency。
			\end{proof}
		\par 上面分析了顺序一致性，PRAM一致性，并根据RPQ的场景提出了适用于RPQ的RPQ Sequential-Consistency和k-RPQ PRAM-Consistency。对于其他的不带时间的一致性模型，下面简要说明一下：
		\begin{itemize}
			\item Atomicity(Linearizability)\cite{herlihy1990linearizability}。比顺序一致性更强的一致性模型\cite{Attiya:1994:SCV:176575.176576}。易见由于RPQ不满足RPQ Sequential-Consistency，故RPQ也不满足Atomicity。
			\item Causal Consistency\cite{ahamad1995causal}。经典的因果一致性并不适合用来分析RPQ，因为作为一个分布式数据结构，RPQ上面操作的因果关系较难定义。本文不再探讨因果一致性。
			\item Eventual Consistency\cite{vogels2009eventually}。最终一致性。极弱的一致性模型。易见由于RPQ满足k-RPQ PRAM-Consistency，故RPQ满足最终一致性。
		\end{itemize}
	\subsection{带绝对时间}
		\par 下面将借助绝对时间，提出适用于RPQ一致性分析的一致性模型。
		\par 由上面的分析可以看到，我们设计的RPQ在偏传统的一致性模型中，支持的是弱的一致性模型。但是RPQ作为一个分布式的数据结构，有着自己的的语义，即max。在很多时候，其实我们更加关注的是当get\_max的时候，是否会获得正确的结果，或者是如果不是正确的结果，那么结果有多么的好。
		\par 由此引入max差异一致性：
		\begin{definition}
			\textbf{max差异一致性} 每次有任何节点进行get\_max操作，都会得到一个$max$值。假设系统第$i$次进行get\_max操作，得到了返回值$max_i$，而这一时刻系统实际的最大值为$max_i'$，那么就有差值$d_i=|max_i-max_i'|$。所有的$d_i$中最大的差值的期望$E\left[ max(d_i)\right] $，就是RPQ的差值一致性。
		\end{definition}
		\par max差异一致性的概念可以进一步范化。由之前的算法设计，可以看到有时候我们除了关注max元素之外，也关注RPQ中前k层的情况。承接之前版本控制的思路，定义一个更加范化的k差异一致性。
		\begin{definition}
			\textbf{k差异一致性} 首先有函数$k=f(size),w_i=g(i)$，其中$size$是RPQ的大小，$w_i$指的是第$i$层的元素的权重。在每个特定的时刻$t$，此时刻全局的RPQ在服务端，而客户端$c_w$中的前k层与它是有差异的，$x$是客户端的元素，$x'$是服务端的元素，它们的下标相同。它们的差异定义为：$$D_w^t=\sum_{l=0}^{f(size)}\sum_{x.level=l}|x-x'|\times g(l)$$对于所有的客户端，在每一个特定的时刻，最大差值的期望$E[max(D_w^t)]$为RPQ的k差异一致性。
		\end{definition}
		\par 于是，max差异一致性，就是$f(size)=0, g(i)=1$且特殊时刻定义为有任何节点进行get\_max操作的时候，成为k差值一致性的一个特例。这个特例也是一个相当重要的特例，因为它与RPQ的语义是最近的。
		\par 像在版本控制设计时候一样，定义不同的$f(size), g(i)$以及特殊的观察时刻，就能定义出不同的差异一致性。
		\par 可以看到上面的一致性都是以数据为中心的，原因在于在分布式移动计算的场景在，对于RPQ，我们最终关系的是其中的数据是否一致。选择以数据为中心的一致性模型来分析RPQ的表现，更加适用于需求。而上面的差异一致性，最终是衡量了RPQ对一致性的保障，也为我们的实验提供了理论框架。